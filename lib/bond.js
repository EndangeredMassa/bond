// Generated by CoffeeScript 2.0.0-beta8
void function () {
  var _find, _registry, allStubs, arrayEqual, bond, cache$, createAnonymousSpy, createReturnSpy, createThroughSpy, deepEqual, enhanceSpy, equal, isFunction, nextTick, registerCleanupHook, registered, registry;
  cache$ = ('undefined' !== typeof window && null != window ? window.assertive : void 0) || require('assertive');
  equal = cache$.equal;
  deepEqual = cache$.deepEqual;
  isFunction = function (obj) {
    return typeof obj === 'function';
  };
  createThroughSpy = function (getValue, bondApi) {
    var spy;
    spy = function () {
      var args, isConstructor, result;
      args = Array.prototype.slice.call(arguments);
      spy.calledArgs[spy.called] = args;
      spy.called++;
      result = getValue.apply(this, args);
      isConstructor = this instanceof arguments.callee;
      if (isConstructor && typeof result !== 'object')
        return this;
      return result;
    };
    return enhanceSpy(spy, getValue, bondApi);
  };
  createReturnSpy = function (getValue, bondApi) {
    var spy;
    spy = function () {
      var args;
      args = Array.prototype.slice.call(arguments);
      spy.calledArgs[spy.called] = args;
      spy.called++;
      return getValue.apply(this, args);
    };
    return enhanceSpy(spy, getValue, bondApi);
  };
  createAnonymousSpy = function () {
    var returnValue, spy;
    returnValue = null;
    spy = function () {
      var args;
      args = Array.prototype.slice.call(arguments);
      spy.calledArgs[spy.called] = args;
      spy.called++;
      return returnValue;
    };
    enhanceSpy(spy);
    spy['return'] = function (newReturnValue) {
      returnValue = newReturnValue;
      return spy;
    };
    return spy;
  };
  enhanceSpy = function (spy, original, bondApi) {
    var k, v;
    spy.prototype = null != original ? original.prototype : void 0;
    spy.called = 0;
    spy.calledArgs = [];
    spy.calledWith = function (args) {
      var lastArgs;
      args = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
      if (!spy.called)
        return false;
      lastArgs = spy.calledArgs[spy.called - 1];
      return arrayEqual(args, lastArgs);
    };
    if (bondApi)
      for (k in bondApi) {
        v = bondApi[k];
        spy[k] = v;
      }
    return spy;
  };
  arrayEqual = function (A, B) {
    var a, b, i;
    for (var i$ = 0, length$ = A.length; i$ < length$; ++i$) {
      a = A[i$];
      i = i$;
      b = B[i];
      if (a !== b)
        return false;
    }
    return true;
  };
  nextTick = function () {
    if (isFunction('undefined' !== typeof process && null != process ? process.nextTick : void 0))
      return process.nextTick;
    if ('undefined' !== typeof setImmediate && null != setImmediate && isFunction(setImmediate))
      return setImmediate;
    return function (fn) {
      return setTimeout(fn, 0);
    };
  }();
  _registry = [];
  _find = function (obj) {
    var store;
    for (var i$ = 0, length$ = _registry.length; i$ < length$; ++i$) {
      store = _registry[i$];
      if (store.obj === obj)
        return store;
    }
    store = {
      obj: obj,
      props: {}
    };
    _registry.push(store);
    return store;
  };
  registry = {
    set: function (obj, prop, value, newValue) {
      var store;
      store = _find(obj);
      if (!(null != store.props[prop]))
        return store.props[prop] = value;
    },
    get: function (obj, prop) {
      return _find(obj).props[prop];
    },
    restore: function (obj, prop) {
      return obj[prop] = _find(obj).props[prop];
    },
    restoreAll: function () {
      var prop, store, value;
      for (var i$ = 0, length$ = _registry.length; i$ < length$; ++i$) {
        store = _registry[i$];
        for (prop in store.props) {
          value = store.props[prop];
          store.obj[prop] = value;
        }
      }
      return _registry = [];
    }
  };
  allStubs = [];
  registered = false;
  registerCleanupHook = function () {
    var after;
    if (registered)
      return;
    after = 'undefined' !== typeof afterEach && null != afterEach ? afterEach : 'undefined' !== typeof testDone && null != testDone ? testDone : null != ('undefined' !== typeof QUnit && null != QUnit ? QUnit.testDone : void 0) ? 'undefined' !== typeof QUnit && null != QUnit ? QUnit.testDone : void 0 : null != bond.cleanup ? bond.cleanup : function () {
      throw new Error('bond.cleanup must be specified if your test runner does not use afterEach or testDone');
    };
    after(function () {
      return registry.restoreAll();
    });
    return registered = true;
  };
  bond = function (obj, property) {
    var asyncReturn, previous, registerRestore, restore, returnMethod, through, to;
    registerCleanupHook();
    if (arguments.length === 0)
      return createAnonymousSpy();
    previous = obj[property];
    registerRestore = function () {
      return registry.set(obj, property, previous);
    };
    restore = function () {
      return registry.restore(obj, property);
    };
    to = function (newValue) {
      registerRestore();
      if (isFunction(newValue))
        newValue = createThroughSpy(newValue, this);
      obj[property] = newValue;
      return obj[property];
    };
    returnMethod = function (returnValue) {
      var returnValueFn;
      registerRestore();
      returnValueFn = function () {
        return returnValue;
      };
      obj[property] = createReturnSpy(returnValueFn, this);
      return obj[property];
    };
    asyncReturn = function (returnValues) {
      returnValues = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
      return to(function (callback) {
        var numArgs$;
        var args;
        if ((numArgs$ = arguments.length) > 1) {
          args = [].slice.call(arguments, 0, numArgs$ - 1);
          callback = arguments[numArgs$ - 1];
        } else {
          args = [];
        }
        if (!isFunction(callback))
          throw new Error('asyncReturn expects last argument to be a function');
        return nextTick(function () {
          return callback.apply(null, [].slice.call(returnValues));
        });
      });
    };
    through = function () {
      registerRestore();
      obj[property] = createThroughSpy(previous, this);
      return obj[property];
    };
    return {
      to: to,
      'return': returnMethod,
      asyncReturn: asyncReturn,
      through: through,
      restore: restore
    };
  };
  bond.bond = bond;
  bond.calledOnceWithArgs = function (name, bondFn, args) {
    args = 3 <= arguments.length ? [].slice.call(arguments, 2) : [];
    equal('calls to ' + name, 1, bondFn.called);
    return deepEqual('' + name + ' args', args, bondFn.calledArgs[0]);
  };
  bond.calledNTimesWithArgs = function (n, name, bondFn, argLists) {
    var args, cache$1;
    argLists = 4 <= arguments.length ? [].slice.call(arguments, 3) : [];
    if (typeof n === 'number') {
      equal('calls to ' + name, n, bondFn.called);
    } else if (null != n) {
      cache$1 = arguments;
      name = cache$1[0];
      bondFn = cache$1[1];
      argLists = 3 <= cache$1.length ? [].slice.call(cache$1, 2) : [];
      cache$1;
    }
    return function (accum$) {
      for (var i$ = 0, length$ = argLists.length; i$ < length$; ++i$) {
        args = argLists[i$];
        n = i$;
        accum$.push('undefined' !== typeof args && null != args ? deepEqual('' + name + ' args, call number ' + (n + 1), args, bondFn.calledArgs[n]) : void 0);
      }
      return accum$;
    }.call(this, []);
  };
  if ('undefined' !== typeof window && null != window)
    window.bond = bond;
  if ('undefined' !== typeof module && null != module ? module.exports : void 0)
    module.exports = bond;
}.call(this);
